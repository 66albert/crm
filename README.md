# crm 企业客户关系管理系统-中信CRM
##  一、用户登录

### 后端实现

#### 整体思路

1. 参数校验
   - 用户姓名	非空判断
   - 用户密码	非空判断
2. 通过用户名查询用户记录，返回用户对象
3. 判断用户对象是否为空
4. 如果用户对象不为空，则将前台传递的用户密码与数据库中的用户密码做比较
5. 判断密码是否正确
6. 如果密码正确，则登录成功，返回结果

#### Controller层（控制层：接收请求，响应结果）

1. 通过形参接收客户端传递的参数
2. 调用业务逻辑层的登录方法，得到登录结果
3. 响应数据给客户端

#### Service层（业务逻辑层：非空判断，条件判断等逻辑处理）

1. 参数判断，判断用户姓名、用户密码非空
   - 如果参数为空，抛出异常（异常会被控制层捕获并处理）
2. 调用数据访问层，通过用户名查询用户记录，返回用户对象
3. 判断用户对象是否为空
   - 如果用户对象为空，抛出异常（异常会被控制层捕获并处理）
4. 判断密码是否正确，比较客户端传递的用户密码与数据库中查询到的用户对象中的用户密码是否相等
   - 如果密码不相等，抛出异常（异常会被控制层捕获并处理）
5. 如果密码正确，则登录成功

#### Dao层（数据访问层：数据库中的增删改查操作）

1. 通过用户名查询用户记录，返回用户对象
#### 细节调整

1. 返回前端的用户数据，需要经过加密，不能直接访问原始数据
2. 成功登录后，跳转到首页，在cookie中通过userID获取对象，将对象信息存放在session作用域中

### 前端实现

1. 调用layui提供方法form.on，提交表单
2. 发送Ajax请求，接收后端传回的数据
3. 判断后端传回的结果对象中的值
4. 如果登录失败，则弹出提示框，显示错误信息
5. 如果登录成功，则将后端传来的用户信息设置到cookie中，并跳转到首页



## 二、修改密码

### 后端实现

#### Controller层

1. 通过形参接收前端传递的参数（原始密码、新密码、确认密码）
2. 通过request对象，获取设置在cookie中的用户ID
3. 调用Service层修改密码的方法，得到ResultInfo对象
4. 返回ResultInfo对象

#### Service层

1. 接收四个参数（用户ID，原始密码，新密码，确认密码）
2. 通过用户ID查询用户记录，返回用户对象
3. 参数校验
   - 待更新用户记录是否存在（用户对象是否为空）
   - 原始密码是否为空
   - 原始密码是否正确（查询的用户对象中的用户密码是否与原始密码一致）
   - 判断新密码是否为空
   - 判断新密码是否与原始密码一致（不允许新密码与原始密码一致）
   - 判断确认密码是否为空
   - 判断确认密码是否与新密码一致
4. 设置用户新密码
   - 需要将新密码通过指定算法进行加密（md5加密）
5. 执行更新操作，判断受影响的行数

#### Dao层

1. 通过用户ID修改用户密码

### 前端实现

1. 设置form表单提交请求的方法
2. 发送Ajax请求，获取页面中输入的表单元素的值
3. 通过回调函数判断是否修改成功
   1. 如果成功则，清空浏览器中的cookie信息
   2. 跳转到登录页面（要跳转到父页面的登录页面，而不是小窗口跳转）



## 三、全局异常处理

原始方法为在service层的方法中抛出异常，在controller层的方法中捕获异常，当实现功能增多时，由于每个controller都需要捕获异常，造成大量代码重复，以及后期维护困难，所以新增全局异常处理类，来处理异常

### 整体思路

1. 定义全局异常处理类，实现HandlerExceptionRsolver接口，重写resolveException方法
2. 添加注解@Component将异常类交给IOC容器进行管理
3. 方法的返回值分类
   - 返回视图
   - 返回数据（JSON数据）
4. 如何判断方法的返回值？
   - 通过方法上是否声明@ResponseBody注解
   - 如果未声明，则表示返回视图
   - 如果声明了，则表示返回数据

### 详细设计

1. 设置默认的异常处理（返回视图）
   - 设置异常信息
   - 设置返回的视图
2. 判断参数中的handler对象是否为HandlerMethod
3. 如果handler是HandlerMethod
   - 将handler转换成HandlerMethod
   - 通过反射获取方法上声明的@ResponseBode注解对象
   - 判断ResponseBody 对象是否为空
     - 如果对象为空，则表示返回的是视图
       - 设置异常信息，返回视图
     - 如果不为空，则表示返回的是数据
       - 设置默认的异常处理
       - 判断异常类型是否为自定义类型
       - 使用流将数据响应出去
       - 设置响应类型及编码格式（响应JSON格式的数据）
       - 将需要返回的对象转换成JSON格式的字符串
       - 输出数据
       - 关闭流

## 四、非法请求拦截

### 整体思路

1. 判断用户是否为登录状态
   - 获取cookie对象，解析用户ID的值
   - 如果用户Id不为空，且数据库中存在对应的用户记录，表示请求合法
   - 否则，请求不合法，进行拦截，重定向到登录页面

### 详细设计

1. 创建方法并继承HandlerInterceptorAdapter适配器，实现拦截功能

2. 重写preHandle()方法（在目标方法（目标资源）执行前，执行的方法）

   - 方法返回boolean类型
   - true：表示目标方法可以被执行
   - false：表示阻止目标方法执行

3. 如何判断用户是否是登录状态

   - 判断cookie中是否存在用户信息（获取用户ID）
   - 数据库中是否存在指定用户ID的值

4. 如果用户是登录状态，则允许目标方法执行

5. 如果用户是非登陆状态，则抛出未登录异常

   - 在全局异常中做判断
   - 如果是未登录异常，则跳转到登录页面

6. 全局异常类配置非法请求拦截

   - 判断是否抛出未登录异常

   - 如果抛出异常，则要求用户登录，重定向跳转到登录页面

   - ```java
     ModelAndView modelAndView = new ModelAndView("redirect:index");
     return modelAndView;
     ```

7. 添加拦截器配置类

   - 重写添加拦截器方法，添加拦截器
   - 设置需要拦截的资源
   - 设置需要放行的资源


